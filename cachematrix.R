# Coursera R programming  April 2014
# Taught by Roger D. Peng, Johns Hopkins
# week 3, programming assignment 2: Caching the Inverse of a Matrix

## overall description of functions:
# For this assignment, I wrote a pair of functions that can calculate and cache the inverse of a matrix.
# The first time a matrix is passed through the functions, the inverse is cached as well as returned.
# If one runs the function again on the same matrix, the inverse is pulled from the cache rather than recomputed.
# To compute the inverse of a new matrix, one "resets" the matrix, clearing the cache, and resetting the process.
# The functions are modeled after the pair of provided example functions that cache the mean of a vector.


## function 1: makeCacheMatrix
# overview:
# This function creates a special "matrix" object that can cache its inverse.
# It takes a matrix 'x' and "bundles" it with a list of four accessory functions that are used to 
# store, access, and refresh the matrix and its inverse. 
# The four functions are:
#       get() used to access the matrix 'x'
#       set() used to reset matrix 'x' with new data and flush the cached inverse.
#       setinverse() used to cache the inverse of matrix 'x'
#       getinverse() used to access the cached inverse of matrix 'x'
# The output of this function is passed in as the argument to the next function cacheSolve() which 
# performs the calculation and retrieval of the inverse.
# Note: to pass in new matrix data and reset the cache, one manipulates the list returned by makeCacheMatrix 
# by calling the set function and passing in the new matrix as an argument. 
# See "resetting the matrix with new data" in the testing section below for an example.

# line by line explanation:
# line 1. argument: a matrix 'x' of data assumed to be invertable (i.e. nonsingular)
# line 2. create an empty object for storing the inverse (inv)
# line 3- 6: create set(), which lets you reset your matrix of data to a new dataset
# ...(i.e. stores the matrix you pass to it via the 'newdata' argument in x, overwriting previous x)
# ...as you reset x with new data, it also clears out the value of the inverse stored in inv
# line 7: create get(), which returns the matrix stored in x
# line 8: create setinverse(), which sets the value of the inverse (i.e. caches the value of the inverse as inv)
# line 9: create getinverse(), which retrieves the value of the cached inverse stored in inv
# lines 10-13: returns all the above functions as a list and closes function

makeCacheMatrix <- function(x = matrix()) { 
    inv <- NULL                   
    set <- function(newdata) {   
        x <<- newdata             
        inv <<- NULL          
    }
    get <- function() x                 
    setinverse <- function(inverse) inv <<- inverse 
    getinverse <- function() inv             
    list(set = set, get = get,           
         setinverse = setinverse,
         getinverse = getinverse)
}

## Function2: cacheSolve
# overview:
# This function computes the inverse of the special "matrix" object returned by makeCacheMatrix above. 
# If the inverse has already been calculated (and the matrix has not changed), 
# then cacheSolve retrieves the inverse from the cache and prints a message telling the user this.
# Otherwise, cacheSolve fetches the matrix data, calculates the inverse, 
# stores the inverse in the cache, and returns the inverse as the result.

# line by line explanation:
# line 1: arguments: chacheSolve takes the "matrix" object generated by makeCacheMatrix
# line 2: runs getinverse() which returns the cached inverse matrix 'inv'. 
# ...If you ran this data through both functions previously, 'inv' is a stored inverse
# ...otherwise inv is empty (i.e. null). 
# lines 3-6: if inv IS NOT empty (i.e. data run before), it prints a message exlpaining that it is getting 
# ...the cached inverse and returns the stored value of inv and stops.
# line 7: if inv IS empty (you're processing new data), it runs get() which returns the matrix 'x'
# line 8: then, it calculates the inverse of 'x' using solve()
# line 9: then, it runs setinverse() which takes the inverse and stores it as 'inv' in the "matrix" object
# lines 10-11: then, it returns the inverse matrix of 'x' as the result and stops

cacheSolve <- function(x, ...) {
    inv <- x$getinverse()
    if(!is.null(inv)) {                                                             
        message("getting cached data") 
        return(inv)                       
    }
    data <- x$get()         
    inv <- solve(data, ...)   
    x$setinverse(inv)           
    inv                       
}

# testing -------------------
# gen some test data - 2 by 2 nonsingluar matrices
# wikipedia: "...a square matrix randomly selected from a continuous uniform distribution on its 
# entries will almost never be singular." So we can hope that our test data is invertable!

# matrix a: consists of 4 numbers pulled from a random uniform distribution with min of 0 and max of 1
a <- matrix(runif(4, min = 0, max = 1), 2, 2) 
a
solve(a) # this calculates the inverse to see what answer we should get

# matrix b: another matrix 2 orders of magnitude greater
b <- matrix(runif(4, min = 100, max = 101), 2, 2)
b
solve(b)

#run functions with a
Mymatrix <- makeCacheMatrix(a)
cacheSolve(Mymatrix)
cacheSolve(Mymatrix)

# reset with new data from b and run cacheSolve again
Mymatrix$set(b)
cacheSolve(Mymatrix)
cacheSolve(Mymatrix)
